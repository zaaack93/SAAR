// Define your custom element class
class WrappingContainer extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    // Create a MutationObserver to watch for changes in the container's content
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (
          mutation.type === "childList" &&
          this.containsYourContent(mutation.target)
        ) {
          // Your content is now available, execute your logic
          this.loadThirdPartyApp();
          observer.disconnect(); // Stop observing once your content is inserted
        }
      }
    });

    // Start observing the container for changes
    observer.observe(this, { childList: true, subtree: true });
  }

  containsYourContent(element) {
    // Implement a function to check if your content is available in the element
    // You can use a specific attribute or element structure to identify it.
    // Return true when your content is found.
    return element.querySelector(".ptw-app-wrapper") !== null;
  }

  loadThirdPartyApp() {
    // Implement your logic to interact with the third-party app here
    // This function will be called when your content is available

    const noteContainer = this.querySelector(".ptw-message-note");
    const newDiv = document.createElement("div");
    newDiv.classList.add("note-label");

    const labelElement = document.querySelector('label[for="ptw-gift-needed"]');

    // Create a new text node with the label's text content
    const labelText = labelElement.cloneNode(true);
    labelText.querySelector("span").remove();
    newDiv.innerHTML = "Add gift wrapping and a personal note";
    noteContainer.prepend(newDiv);

    // Get the label element by the 'for' attribute
    const labelElement1 = document.querySelector(
      'label[for="ptw-gift-needed"]'
    );
    const ptwPrice = labelElement1.querySelector(".ptw-price");
    ptwPrice.textContent = ptwPrice.textContent.replace(/[\(\)\s]/g, "");

    // Update the text content of the label
    labelElement1.textContent = "Custom Gift Packing";

    const newDivPrice = document.createElement("div");
    newDivPrice.classList.add("ptw-price");
    newDivPrice.innerHTML = ptwPrice.textContent;
    labelElement1.prepend(newDivPrice);


    let linkElement = document.querySelector('link[href*="wrapin.css"]');

    // Check if the <link> element exists
    if (linkElement) {
      // Remove the <link> element from the DOM
      linkElement.parentNode.removeChild(linkElement);
    }

    //trigger refressh scroll slider
    const event = new CustomEvent('slider-scroll:refresh', {
      bubbles: true, // Allows the event to bubble up the DOM
    });

    // Dispatch the custom event
    this.dispatchEvent(event);
  }
}

// Define your custom element using the customElements API
customElements.define("wraping-container", WrappingContainer);


// this wraper is for waiting the zepto personalizer to initiate
class FormWrappingContainer extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    const observerCallback = (mutationsList, observer) => {
      for (const mutation of mutationsList) {
        if (
          mutation.type === "childList" &&
          this.containsYourContent(mutation.target)
        ) {
          // Your content is now available, execute your logic
          this.loadThirdPartyApp();
          // Stop observing once your content is inserted
          observer.disconnect();
        }
      }
    }
  
    // Create a MutationObserver with a callback that can reference the observer itself
    const observer = new MutationObserver(mutationsList => observerCallback(mutationsList, observer));
  
    // Start observing the container for changes
    observer.observe(this, { childList: true, subtree: true });
  }

  containsYourContent(element) {
    // Implement a function to check if your content is available in the element
    // You can use a specific attribute or element structure to identify it.
    // Return true when your content is found.
    return element.querySelector(".product-personalizer") !== null;
  }

  loadThirdPartyApp() {
    //this for wrappe it inside a tag 
    if(!this.querySelector('product-personalizer-wrapper')){
      // Step 1: Select the div element with the "product-personalizer" class
      let divElement = this.querySelector(".product-personalizer");
      if (divElement) {
        // Create a new <wrapper> element
        let wrapperElement = document.createElement('product-personalizer-wrapper');
        //hide the personalizer until we do all the stuff
        wrapperElement.style.display="none";
        // Clone the <legend> element
        let clonedLegend = divElement.cloneNode(true);

        // Append the cloned <legend> element to the <wrapper> element
        wrapperElement.appendChild(clonedLegend);

        // Replace the <legend> element with the <wrapper> element in the DOM
        divElement.parentNode.replaceChild(wrapperElement, divElement);


        // Select the .product_customizar_options <div>
        var productOptionsDiv = document.querySelector('.product_customizar_options');

        if (productOptionsDiv) {
            // Prepend the new element to the beginning of the .product_customizar_options <div>
            productOptionsDiv.insertBefore(this.querySelector("product-personalizer-wrapper"), productOptionsDiv.firstChild);
        }
      }
    }
  }
}

// Define your custom element using the customElements API
customElements.define("form-wrapping-container", FormWrappingContainer);

//zepto personalizer web component
class ProductPersonalizerWrapper extends HTMLElement {
  constructor() {
    super();
    // Find elements within the shadow DOM
    this.updatePriceLineCustomizer()
  }

  updatePriceLineCustomizer() {
    setTimeout(()=>{
      const dateMainF = this.querySelector('.pplr-wrapper[data-main="1"]')
      if(dateMainF){
        const customizationPrice=dateMainF.querySelector('.pplrcheckbox.pplraddprice')
        const newSpanPrice = document.createElement("span");
        newSpanPrice.classList.add("pplr_option_price_span");
        
        
        if(customizationPrice==null){
          newSpanPrice.innerHTML = 'Free';
        }
        else{
          newSpanPrice.innerHTML = `$${customizationPrice.dataset.pplr_price}`;
        }
        dateMainF.append(newSpanPrice);
      }

      //wrapp alll the query selector and wrappe theme inside a div
      // Create a new div element to be the wrapper
      let wrapper = document.createElement('div');
      wrapper.classList.add('mains-wrapper');

      // Get all the .pplr-wrapper divs
      const allWrapper = this.querySelectorAll('.pplr-wrapper');

      allWrapper.forEach((wrapperDiv) => {
        if (wrapperDiv.getAttribute('data-main') != '1') {
          // Clone the div that meets the condition and append it to the wrapper
          let cloneDiv = wrapperDiv.cloneNode(true);
          if(wrapperDiv.classList.contains('pplr-text')){
            const labelPlacement = cloneDiv.querySelector('.pplrlabel');
            if(labelPlacement.textContent.trim()!=""){
              labelPlacement.classList.add('label-with-check')
              const newCheckBox = document.createElement("input");
              newCheckBox.type = "checkbox";
              labelPlacement.prepend(newCheckBox);
            }
            else{
              cloneDiv.querySelector('input[type="text"]').name=`properties[${cloneDiv.querySelector('.oindexlabel').textContent}]`
            }

            //recalculate pplr account 
            cloneDiv.querySelector('input[type="text"]').addEventListener('input',(e)=>{
              setTimeout(() => {
                cloneDiv.querySelector('.pplr-character-count .ct').textContent=e.target.value.length
              }, 300);
            })
            cloneDiv.querySelector('.pplr-character-count .ct').textContent=cloneDiv.querySelector('input[type="text"]').value.length
          }
          wrapper.appendChild(cloneDiv);
          wrapperDiv.replaceWith(wrapper);
        }
      });
      this.style.display="initial";
      //trigger refressh scroll slider
      const event = new CustomEvent('slider-scroll:refresh', {
        bubbles: true, // Allows the event to bubble up the DOM
      });

      // Dispatch the custom event
      this.dispatchEvent(event);
    },300)
  }
}

customElements.define('product-personalizer-wrapper', ProductPersonalizerWrapper);

// scroll slider container

class ScrollContainer extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    const container = this.querySelector('.inner_container_items');
    const leftButton = this.querySelector('.left-button');
    const rightButton = this.querySelector('.right-button');

    // Add a 'slide-directly-edge' attribute and check its value
    const slideDirectlyEdge = this.hasAttribute('slide-directly-edge');

    const updateButtonVisibility = () => {
      // Show/hide the left button based on scroll position
      if (container.scrollLeft > 0 && leftButton) {
        leftButton.style.visibility = 'visible';
      } else if (leftButton) {
        leftButton.style.visibility = 'hidden';
      }
      // Show/hide the right button based on scroll position
      if (container.scrollLeft < container.scrollWidth - container.clientWidth - 10 && rightButton) {
        rightButton.style.visibility = 'visible';
      } else if (rightButton) {
        rightButton.style.visibility = 'hidden';
      }
    };

    const scrollHandler = () => {
      updateButtonVisibility();
    };

    const resizeHandler = () => {
      updateButtonVisibility();
    };

    leftButton?.addEventListener('click', () => {
      if (slideDirectlyEdge) {
        container.scrollLeft = 0; // Scroll to the left edge
      } else {
        container.scrollLeft -= 300; // Normal scrolling
      }
    });

    rightButton?.addEventListener('click', () => {
      if (slideDirectlyEdge) {
        container.scrollLeft = container.scrollWidth - container.clientWidth; // Scroll to the right edge
      } else {
        container.scrollLeft += 300; // Normal scrolling
      }
    });

    container?.addEventListener('scroll', scrollHandler);
    window.addEventListener('resize', resizeHandler);

    updateButtonVisibility(); // Trigger initial visibility check

    // Add an event listener for the refresh scroll
    this.addEventListener('slider-scroll:refresh', updateButtonVisibility);
  }
}

customElements.define('scroll-wrapper-slider', ScrollContainer);

class horizontalProductCard extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    const questionButton = this.querySelector('.question-icon');
    const removeButton = this.querySelector('.remove-icon');
      
    questionButton?.addEventListener('click', () => {
      this.classList.add('expanded-area-button')
    });

    removeButton?.addEventListener('click', () => {
      this.classList.remove('expanded-area-button')
    });
  }
}



customElements.define('horizontal-product-card', horizontalProductCard);

class SwiperComponent extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    this.initSwiper();
  }

  initSwiper() {
    // Retrieve options from data attributes
    const loop = this.getAttribute('data-loop') === 'true';
    const autoplay = parseInt(this.getAttribute('data-autoplay')) || false;

    // Configure Swiper with the retrieved options
    const swiperOptions = {
      slidesPerView: 5,
      spaceBetween: 20,
      freeMode: true,
      autoHeight:true,
      loop:true,
      grabCursor: true,
      pagination: {
        el: ".swiper-pagination",
        clickable: true,
      },
    };

    const mySwiper = new Swiper(this, swiperOptions);
  }
}

customElements.define('swiper-component', SwiperComponent);